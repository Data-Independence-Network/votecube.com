<svelte:document
    on:click="onDocumentClick(event)"
    on:keydown="onDocumentKeydown(event)"
></svelte:document>
{#if $forms}
<div
    class="multiSelect"
>
    <label
        class="field-label"
        use:for="{id}"
    >{label}</label>
    <section
        class="dropdownAnchor field fieldBox"
        class:invalid="touched && errors.length"
        class:requiredInvalid="field.validatorMap.required && errors.length"
        class:requiredValid="field.validatorMap.required && !errors.length"
        on:click="showOptions(this, event)"
        ref:field
    >
        <div
            class="selections"
            style="
                width: {selectionWidth}
            "
            >
            <div
                class="selectionSizer"
                ref:selectionSizer
            >

    {#each selections as selection}
                <section
                    class="selection"
                >
                    <div
                        class="selection-contents"
                    >
                    {selection.text}
                    </div>
                    <span
                        class="unselect"
                        on:click="unselect(selection, event)"
                    >
                        <s class="bar"></s>
                        <s class="bar"></s>
                    </span>
                </section>
    {/each}
                <input
                    bind:value="filter"
                    type="text"
                    ref:filter
                    use:id="{id}"
                >
            </div>
        </div>
        <div
            class="icons"
            style="
                width: {aidWidth}
            "
        >
            <div
                class="multiRowIconsCenter"
            >
                <InfoIcon
                    on:select="help()"
                    multiLine="y"
                ></InfoIcon>
                <ClearIcon
                    on:select="clear()"
                    multiLine="y"
                ></ClearIcon>
            </div>
        </div>
    </section>
    {#if showOptions && options.length}
    <ul
        class="dropdown"
        style="
            top: {dropdownTopPx}px;
        "
    >
        {#each options as option, index}
        <li
            class="option"
            class:activeOption="index === activeOptionIndex"
            on:click="select(option)"
        >{option.text}</li>
        {/each}
    </ul>
    {/if}
    {#if touched}
        {#each errors as error}
    <span class="pure-form-message error">{error.message}</span>
        {/each}
    {/if}
</div>
{/if}

<style>

    input[type="text"] {
        border: 0;
        box-shadow: none;
        color: #222;
        display: inline-block;
        font-weight: 600;
        margin: 0;
        padding-left: 5px;
        vertical-align: text-bottom;
        width: 50px;
    }

    li {
        font-weight: 600;
        list-style: none;
        padding: 10px;
    }

    li + li {
        border-top: 1px solid #f8f8f8;
    }

    li:hover {
        background-color: #eee;
    }

    ul {
        max-height: 300px;
        padding: 0;
        width: 100%;
    }

    .fieldBox {
        background-color: white;
        min-height: 2.25em;
        padding-bottom: 5px;
        position: relative;
        width: 100%;
    }

    .icons {
        display: inline-block;
        height: 100%;
        position: absolute;
        right: 0px;
        top: 0px;
    }

    .multiRowIconsCenter {
        padding-top: 5px;
        position: relative;
        top: 50%;
        transform: translateY(-50%);
    }

    .multiSelect {
        position: relative;
    }

    .selection {
        /*background-color: #808080;*/
        /*border: 1px solid #777;*/
        background-color: #ccc;
        border: 1px solid #222;
        border-radius: 3px;
        color: #333;
        /*color: #fff;*/
        display: inline-block;
        font-weight: 600;
        margin: 6px 0 0 6px;
        padding-left: 8px;
    }

    .selection-contents {
        float: left;
        padding: 8px 2px 0 0;
    }

    .selections {
        display: inline-block;
    }

    .selectionSizer {
        display: inline-block;
    }

    .unselect {
        display: inline-block;
        height: 26px;
        margin-top: 4px;
        position: relative;
        width: 30px;
    }

    .unselect .bar {
        /*background-color: #fff;*/
        background-color: #222;
        display: block;
        height: 3px;
        width: 16px;
        position: absolute;
        right: 8px;
        top: 12px;
    }

    .unselect .bar:first-child {
        transform: rotate(-45deg);
    }

    .unselect .bar:last-child {
        transform: rotate(45deg);
    }

</style>

<script>
import store from '../../store'
import {removeWatch, watchMultilineField} from '../../watch'
import InfoIcon from '../icon/InfoIcon.html'
import ClearIcon from '../icon/ClearIcon.html'

export default {
    actions: {
        for(node, id) {
            if(id) {
                node.id = id;
            }
        },
        id(node, id) {
            if(id) {
                node.id = id;
            }
        }
    },
    components: {
        ClearIcon,
        InfoIcon
    },
    computed: {
        aidWidth: ({sizeDiff}) => sizeDiff < 34
            ? '33px'
            : 'auto',
        errors: ({delta, field}) => field.errors,
        label: ({delta, field}) => field.label,
        options: ({delta, field, filter}) => filter
        ? field.multiOptions
            .filter(option =>
                option.text.toLowerCase().indexOf(filter.toLowerCase()) > -1)
        : field.multiOptions,
        selections: ({delta, field}) => field.value,
        selectionWidth: ({sizeDiff}) => sizeDiff < 34
            ? 'calc(100% - 33px)'
            : 'calc(100% - 70px)',
        touched: ({delta, field}) => field.touched
    },
    data() {
        return {
            filter: '',
            activeOptionIndex: 0
        }
    },
    immutable: true,
    methods: {
        clear() {
            this.get().field.clear()
            this.refs.filter.value = ''
        },
        help() {
            const text = this.get().field.text
            this.store.setTextToast( text.info, text.infoSeconds)
        },
        hideOptions() {
            this.set({showOptions: false})
        },
        onBlur() {
            this.get().field.onBlur()
        },
        onDocumentClick(event) {
            this.hideOptions()
        },
        onDocumentKeydown(event) {
            let {activeOptionIndex, filter, options, showOptions} = this.get()
            if(!showOptions) {
                return
            }
            showOptions = true
            switch(event.key) {
                case 'ArrowDown':
                    if(activeOptionIndex + 1 < options.length) {
                        activeOptionIndex++
                    }
                    break;
                case 'ArrowUp':
                    if(activeOptionIndex) {
                        activeOptionIndex--
                    }
                    break;
                case 'Escape':
                    activeOptionIndex = 0
                    showOptions = false
                    break;
                case 'Enter':
                    this.get().field.select(options[activeOptionIndex])
                    activeOptionIndex = 0
                    filter = ''
                    showOptions = false
                    event.preventDefault()
                    break;
            }
            if(!showOptions) {
                this.hideOptions()
            }
            this.set({activeOptionIndex, filter})
        },
        select(option) {
            this.get().field.select(option)
            this.hideOptions()
            this.set({filter: ''})
        },
        showOptions(element, event) {
            if(!this.get().showOptions) {
                if(this.get().field.multiOptions.length) {
                    this.set({
                        showOptions: true,
                        dropdownTopPx: element.offsetHeight + 6
                    })
                    event.stopPropagation()
                }
            }
            this.refs.filter.focus()
        },
        unselect(option, event) {
            this.get().field.unselect(option)
            event.stopPropagation()
            this.set({filter: ''})
        }
    },
    oncreate() {
        const field = this.get().field
        this.get().field.pages.push(this)
        watchMultilineField(this, this.refs.field, this.refs.selectionSizer)
    },
    ondestroy() {
        removeWatch(this)
    },
    store: () => store
}

</script>
