<svelte:document
    on:click="onDocumentClick(event)"
    on:keydown="onDocumentKeydown(event)"
></svelte:document>
{#if $forms}
<div
    class="autoComplete"
>
    <label
        class="field-label"
        use:for="{id}"
    >
        {label}
    </label>
    <section
        class="dropdownAnchor field fieldBox"
        class:invalid="touched && errors.length"
        class:requiredInvalid="field.validatorMap.required && errors.length"
        class:requiredValid="field.validatorMap.required && !errors.length"
        on:click="showOptions(this, event)"
        ref:field
    >
        <div
            class="selection"
        >
            <input
                autocomplete="off"
                bind:value="filter"
                on:input="checkValue(options)"
                ref:filter
                type="text"
                use:id="{id}"
            >
        </div>
        <div
            class="icons"
        >
            <div>
                <ClearIcon
                    on:select="clear()"
                    multiLine="y"
                ></ClearIcon>
                <InfoIcon
                    on:select="help()"
                    multiLine="y"
                ></InfoIcon>
            </div>
        </div>
    </section>
    {#if showOptions && options.length}
    <ul
        class="dropdown"
        style="
            top: {dropdownTopPx}px;
        "
    >
        {#each options as option, index}
        <li
            class="option"
            class:activeOption="index === activeOptionIndex"
            on:click="select(option)"
        >
            {option.text}
        </li>
        {/each}
    </ul>
    {/if}
    {#if touched}
        {#each errors as error}
    <span class="pure-form-message error">{error.message}</span>
        {/each}
    {/if}
</div>
{/if}

<style>

    input[type="text"] {
        border: 0;
        box-shadow: none;
        color: #222;
        display: inline-block;
        font-weight: 600;
        margin: 0;
        margin-top: 8px;
        padding-left: 5px;
        vertical-align: text-bottom;
        width: 100%;
    }

    li {
        font-weight: 600;
        list-style: none;
        padding: 10px;
    }

    li + li {
        border-top: 1px solid #f8f8f8;
    }

    li:hover {
        background-color: #eee;
    }

    ul {
        max-height: 300px;
        padding: 0;
        width: 100%;
    }

    .autoComplete {
        position: relative;
    }

    .activeOption {
        background-color: #eee;
    }

    .fieldBox {
        background-color: white;
        min-height: 2.25em;
        padding-bottom: 5px;
        position: relative;
        width: 100%;
    }

    .icons {
        display: inline-block;
        height: 100%;
        position: absolute;
        right: 0px;
        top: 0px;
    }

    .filteredRowIconsCenter {
        padding-top: 5px;
        position: relative;
        top: 50%;
        transform: translateY(-50%);
    }
/*
    .multiRowIconsCenter {
        padding-top: 5px;
        position: relative;
        top: 50%;
        transform: translateY(-50%);
    }*/

    .selection {
        display: inline-block;
        width: calc(100% - 70px);
    }

</style>

<script>
import {ACTIONS, COMPUTED, OPTIONS} from '../../forms'
import store from '../../store'
import InfoIcon from '../icon/InfoIcon.html'
import ClearIcon from '../icon/ClearIcon.html'

export default {
    actions: {
        for(node, id) {
            if(id) {
                node.id = id;
            }
        },
        id(node, id) {
            if(id) {
                node.id = id;
            }
        }
    },
    components: {
        ClearIcon,
        InfoIcon
    },
    computed: {
        errors: ({delta, field}) => field.errors,
        label: ({delta, field}) => field.label,
        options: ({delta, field, filter}) => filter
            ? field.filteredOptions
                .filter(option =>
                    option.text.toLowerCase().indexOf(filter.toLowerCase()) > -1)
            : field.filteredOptions,
        touched: ({delta, field}) => field.touched
    },
    data() {
        return {
            filter: '',
            activeOptionIndex: 0
        }
    },
    immutable: true,
    methods: {
        checkValue(options) {
            const {field, filter} = this.get()
            OPTIONS.showFiltered(this, this.refs.field)
            if(field.value
                && field.value.text.toLowerCase() !== filter.toLowerCase()) {
                field.unselect()
                return
            }
            if(options.length !== 1) {
                return
            }
            const theOption = options[0]
            if(filter.toLowerCase() === theOption.text.toLowerCase()) {
                this.get().field.select(theOption)
            }
        },
        clear() {
            this.get().field.clear()
            this.refs.filter.value = ''
        },
        help() {
            const text = this.get().field.text
            this.store.setTextToast( text.info, text.infoSeconds)
        },
        hideOptions() {
            this.set({showOptions: false})
        },
        onDocumentClick(event) {
            this.hideOptions()
        },
        onDocumentKeydown(event) {
            OPTIONS.handleKeydown(this)
        },
        select(option) {
            this.get().field.select(option)
            this.refs.filter.value = option.text
            this.hideOptions()
        },
        showOptions(element, event) {
            OPTIONS.showFiltered(this, element
            // , true
            )
        }
    },
    oncreate() {
        this.get().field.setAsField(this)
    },
    ondestroy() {
        this.get().field.removeComponent(this)
    },
    store: () => store
}

</script>
