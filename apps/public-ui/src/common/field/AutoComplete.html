<svelte:document
				on:click="onDocumentClick(event)"
				on:keydown="onDocumentKeydown(event)"
></svelte:document>
{#if $forms}
<div
				class="autoComplete"
>
	<label
					class="field-label"
					use:for="{id}"
	>
		{label}
	</label>
	<section
					class="dropdownAnchor field fieldBox"
					class:invalid="touched && errors.length"
					class:modified="modified"
					class:requiredInvalid="requiredInvalid"
					class:requiredValid="requiredValid"
					on:click="showOptions(this, event)"
					ref:field
	>
		<div
						class="selection"
		>
			<input
							autocomplete="off"
							bind:value="filter"
							on:blur="blur()"
							on:input="checkValue(options)"
							ref:filter
							type="text"
							use:id="{id}"
			>
		</div>
		<div
						class="icons"
		>
			<div>
				{#if trackOriginal}
				<UndoIcon
								multiLine="y"
								on:select="revert()"
				></UndoIcon>
				{:else}
				<ClearIcon
								multiLine="y"
								on:select="clear()"
				></ClearIcon>
				{/if}
				<InfoIcon
								on:select="help()"
				></InfoIcon>
			</div>
		</div>
	</section>
	{#if showOptions && options.length}
	<ul
					class="dropdown"
					style="
            top: {dropdownTopPx}px;
        "
	>
		{#each options as option, index}
		<li
						class="option"
						class:activeOption="index === activeOptionIndex"
						on:click="select(option)"
		>
			{option.text}
		</li>
		{/each}
	</ul>
	{/if}
	{#if touched}
	{#each errors as error}
	<span class="pure-form-message error">{error.message}</span>
	{/each}
	{/if}
</div>
{/if}

<style>

	input[type="text"] {
		border: 0;
		box-shadow: none;
		color: #222;
		display: inline-block;
		font-weight: 600;
		margin: 0;
		margin-top: 8px;
		padding-left: 5px;
		vertical-align: text-bottom;
		width: 100%;
	}

	li {
		font-weight: 600;
		list-style: none;
		padding: 10px;
	}

	li + li {
		border-top: 1px solid #f8f8f8;
	}

	li:hover {
		background-color: #eee;
	}

	ul {
		max-height: 300px;
		padding: 0;
		width: 100%;
	}

	.autoComplete {
		position: relative;
	}

	.activeOption {
		background-color: #eee;
	}

	.fieldBox {
		background-color: white;
		min-height: 2.25em;
		padding-bottom: 5px;
		position: relative;
		width: 100%;
	}

	.icons {
		display: inline-block;
		height: 100%;
		position: absolute;
		right: 0px;
		top: 1px;
	}

	.selection {
		display: inline-block;
		width: calc(100% - 70px);
	}

</style>

<script>
	import {
		ACTIONS,
		COMPUTED,
		OPTIONS
	}                from '../../form/forms'
	import store     from '../../store'
	import ClearIcon from '../icon/ClearIcon.html'
	import InfoIcon  from '../icon/InfoIcon.html'
	import UndoIcon  from '../icon/UndoIcon.html'

	export default {
		actions: {
			for(node, id) {
				if (id) {
					node.id = id;
				}
			},
			id(node, id) {
				if (id) {
					node.id = id;
				}
			}
		},
		components: {
			ClearIcon,
			InfoIcon,
			UndoIcon
		},
		computed: {
			errors: ({delta, field}) => field.errors,
			label: ({delta, field}) => field.label,
			modified: ({delta, errors, field}) =>
				!errors.length && field.rules.trackOriginal && !field.theIsOriginal,
			options: ({delta, field, filter}) => filter
				? field.filteredOptions
					.filter(option =>
						option.text.toLowerCase().indexOf(filter.toLowerCase()) > -1)
				: field.filteredOptions,
			requiredInvalid: ({delta, errors, field}) =>
				field.validatorMap.required && errors.length,
			requiredValid: ({delta, errors, field, modified}) =>
				!modified && field.validatorMap.required && !errors.length,
			touched: ({delta, field}) => field.touched,
			trackOriginal: ({delta, field}) => field.rules.trackOriginal
		},
		data() {
			return {
				filter: '',
				activeOptionIndex: 0
			}
		},
		immutable: true,
		methods: {
			blur() {
				const {field} = this.get()
				field.touch()
				field.detect()
			},
			checkValue(options) {
				const {field, filter} = this.get()
				OPTIONS.showFiltered(this, this.refs.field)
				if (field.value
					&& field.value.text.toLowerCase() !== filter.toLowerCase()) {
					field.unselect()
					return
				}
				if (options.length !== 1) {
					return
				}
				const theOption = options[0]
				if (filter.toLowerCase() === theOption.text.toLowerCase()) {
					this.get().field.select(theOption)
				}
			},
			clear() {
				this.get().field.clear()
				this.refs.filter.value = ''
			},
			help() {
				const text = this.get().field.text
				this.store.setTextToast(text.info, text.infoSeconds)
			},
			hideOptions() {
				this.set({showOptions: false})
			},
			onDocumentClick(event) {
				this.hideOptions()
			},
			onDocumentKeydown(event) {
				OPTIONS.handleKeydown(this)
			},
			revert() {
				const {field} = this.get()
				field.revert()
				const value = field.theValue
				if (value) {
					this.refs.filter.value = value.text
				} else {
					this.refs.filter.value = ''
				}
			},
			select(option) {
				this.get().field.select(option)
				this.refs.filter.value = option.text
				this.hideOptions()
			},
			showOptions(element, event) {
				OPTIONS.showFiltered(this, element
					// , true
				)
			}
		},
		oncreate() {
			const {field} = this.get()
			field.setAsField(this)
			const value = field.value
			if (value) {
				this.set({filter: value.text})
			}
		},
		ondestroy() {
			this.get().field.removeComponent(this)
		},
		store: () => store
	}

</script>
