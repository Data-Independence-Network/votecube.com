<figure
		id="cube"
>
	<!--			on:click="toggleView(cubeView, event)"-->
	{#if poll && factorsByAxis}
	{#each positions as position, i}
	<div
			class="surface {loading ? 'loading' : ''} {rotating ? 'rotating' : ''}"
			id="s{i}"
			style="
            background-color: #{getColor(factorsByAxis[position.axis].color, logicUtils)};
              "
	>
		{#if !loading && !rotating}
		<header>
			{#if positionsByAxisAndDir[position.axis][position.dir].outcome === 'A'}
			<CharacterButton
					character="A"
					fontSize="23"
					fontX="14.5"
					fontY="23"
					size="30"
					strokeWidth="0"
					styles="left: 1px; position: absolute; top: 0px;"
			></CharacterButton>
			{/if}
			{factorsByAxis[position.axis].name}
			{#if positionsByAxisAndDir[position.axis][position.dir].outcome === 'B'}
			<CharacterButton
					character="B"
					fontSize="23"
					fontX="14.5"
					fontY="23"
					size="30"
					strokeWidth="0"
					styles="right: 1px; position: absolute; top: 0px;"
			></CharacterButton>
			{/if}
		</header>
		{#if positionMode}
		<Positioner
				on:moveRight="moveRight(position.axis, position.dir, positionsByAxisAndDir)"
				on:moveDown="moveDown(position.axis, position.dir, positionsByAxisAndDir)"
				on:moveLeft="moveLeft(position.axis, position.dir, positionsByAxisAndDir)"
				on:moveUp="moveUp(position.axis, position.dir, positionsByAxisAndDir)"
				on:switchDir="switchDir(position.axis, position.dir, positionsByAxisAndDir)"
		></Positioner>
		{/if}
		<p
				style="color: #{getTextColor(factorsByAxis[position.axis].color, logicUtils)};"
		>
			{positionsByAxisAndDir[position.axis][position.dir].name}
		</p>
		{/if}
	</div>
	{/each}
	{/if}
</figure>
<style>

	/*
	@media (min-width: 321px) {

		figure#cube > div {
			font-size: 1.9em;
			line-height: 1.2em;
		}

	}

	@media (min-width: 376px) {
		figure#cube > div {
			font-size: 2.1em !important;
			line-height: 1.3em !important;
		}
	}
	 */

	#cube {
		height: 320px;
		margin: auto;
		position: relative;
		/*transform: rotateX(0deg) rotateY(-90deg);*/
		transform-style: preserve-3d;
		/*top: 50%;*/
		width: 320px;
	}

	#cube > div {
		/*border: 5px groove gray;*/
		border: 5px solid gray;
		border-radius: 10px;
		color: #000;
		/*font-size: 2.0em;*/
		font-size: 1.7em;
		font-weight: bold;
		/*height: 320px;*/
		height: 311px;
		/*line-height: 2.0em;*/
		line-height: 1.2em;
		position: absolute;
		/*width: 320px;*/
		width: 311px;
		/*
		height: 360px;
		width: 360px;
		padding: 20px;
		font-size: 1.8em;
		line-height: 2em;
		*/
	}


	#s0 {
		/*background: hsla(  0, 100%, 50%, 0.95);*/
		transform: rotateX(90deg) translateZ(160px) /*translateZ(200px)*/;
	}

	#s1 {
		transform: translateZ(160px) /*translateZ(200px)*/;
	}

	#s2 {
		transform: rotateY(90deg) translateZ(160px) /*translateZ(200px)*/;
	}

	#s3 {
		transform: rotateY(180deg) translateZ(160px) /*translateZ(200px)*/;
	}

	#s4 {
		transform: rotateY(-90deg) translateZ(160px) /*translateZ(200px)*/;
	}

	#s5 {
		transform: rotateX(-90deg) rotate(180deg) translateZ(160px) /*translateZ(200px)*/;
	}

	div {
		transition: width 700ms, height 700ms, transform 700ms;
		transition-timing-function: ease-out;
	}

	div.rotating {
		transform: rotateX(180deg) rotateY(180deg) !important;
	}

	div.loading {
		width: 1px !important;
		height: 1px !important;
	}

	/*footer,*/
	header {
		color: #fff;
		background-color: #000;
		font-size: 0.8em;
		font-weight: 500;
		height: 30px;
		line-height: 1em;
		overflow: hidden;
		position: relative;
		text-align: center;
		text-overflow: ellipsis;
		width: 100%;
		white-space: nowrap;
	}

	header {
		top: 0px
	}

	/*	footer {
			bottom: 0px;
			position: absolute;
		}*/

	p {
		margin: 0;
		margin-block-start: 0em;
		margin-block-end: 0em;
		padding: 0 10px;
		word-break: break-word;
	}

	/*	span {
			position: absolute;
			left: 55px;
			top: 7px;
		}

		span {
			display: inline-block;
		}*/

	.surface {
		position: relative;
	}

</style>

<script>
	import {DI}            from '@airport/di'
	import {
		CUBE_EVENT_LISTENER,
		MUTATION_API
	}                      from '@votecube/cube-logic'
	import {LOGIC_UTILS}   from '@votecube/public-logic'
	import CharacterButton from '../../common/control/button/CharacterButton.html'
	import Positioner      from './create/Positioner.html'

	export default {
		components: {
			CharacterButton,
			Positioner
		},
		computed: {
			horizontalLayout: ({verticalLayout}) => !verticalLayout
		},
		data() {
			return {
				loading: true,
				positions: [],
				rotating: false
			}
		},
		helpers: {
			getColor: (
				color,
				logicUtils
			) => {
				if (!logicUtils) {
					return 'FFF'
				}
				return logicUtils.getColor(color)
			},
			getTextColor: (
				color,
				logicUtils
			) => {
				if (!logicUtils) {
					return '000'
				}
				return logicUtils.getTextColor(color)
			}
		},
		methods: {
			moveDown(
				axis,
				dir,
				positionsByAxisAndDir
			) {
				move(this, positionsByAxisAndDir, axis, dir, [
					['y', 1], // x+
					['y', 1], // x-
					['x', -1], // y+
					['x', -1], // y-
					['x', -1], // z+
					['x', -1] // z-
				])
			},
			moveLeft(
				axis,
				dir,
				positionsByAxisAndDir
			) {
				move(this, positionsByAxisAndDir, axis, dir, [
					['z', -1], // x+
					['z', 1], // x-
					['z', -1], // y+
					['z', 1], // y-
					['y', 1], // z+
					['y', -1] // z-
				])
			},
			moveRight(
				axis,
				dir,
				positionsByAxisAndDir
			) {
				move(this, positionsByAxisAndDir, axis, dir, [
					['z', 1], // x+
					['z', -1], // x-
					['z', 1], // y+
					['z', -1], // y-
					['y', -1], // z+
					['y', 1] // z-
				])
			},
			moveUp(
				axis,
				dir,
				positionsByAxisAndDir
			) {
				move(this, positionsByAxisAndDir, axis, dir, [
					['y', -1], // x+
					['y', -1], // x-
					['x', 1], // y+
					['x', 1], // y-
					['x', 1], // z+
					['x', 1] // z-
				])
			},
			switchDir(
				axis,
				dir,
				positionsByAxisAndDir
			) {
				switchPoles(this, positionsByAxisAndDir, axis, dir)
			},
			/*			toggleView(
							cubeView,
							event
						) {
							if (!cubeView) {
								this.fire('select', event)
							}
						}*/
		},
		oncreate() {
			initPage(this).then()
		},
		ondestroy() {
			stopPage(this).then()
		}
		// onstate({changed, current}) {
		// 	if (!current.pFPsByAxisAndDir) {
		// 		return
		// 	}
		//
		// 	// let cubeElement
		// 	// if (changed.cubeView) {
		// 	// 	let options = {
		// 	// 		// x: 400,
		// 	// 		// y: 400,
		// 	// 		// duration: 700
		// 	// 	}
		// 	// 	// cubeElement = document.getElementById('cube')
		// 	// 	// cubeElement.classList.remove('cubeView')
		// 	// 	// if (current.cubeView) {
		// 	// 	// 	cubeElement.classList.add('cubeView')
		// 	// 	// 	// options.x = -options.x
		// 	// 	// 	// options.y = -options.y
		// 	// 	// }
		// 	// 	setTimeout(() => {
		// 	// 		transition(this, 'viewport', fade, options)
		// 	// 	})
		// 	// }
		//
		// 	if (changed.moveType) {
		// 		cubeElement = document.getElementById('cube')
		// 		cubeElement.classList.remove('toggle')
		// 		if (current.moveType === 'toggle') {
		// 			cubeElement.classList.add('toggle')
		// 		}
		// 	}
		// }
	}

	async function initPage(
		page
	) {
		const container = DI.ui('DetailedCube')
		const [cubeEventListener, mutationApi] =
			      await container.get(CUBE_EVENT_LISTENER, MUTATION_API)

		cubeEventListener.setView('cube')

		await mutationApi.recompute()
		page.stateListener = this.on('state', ({changed, current, previous}) => {
			if (current.vote) {
				page.get().vote.changeMillis = 128
				if (page.stateListener) {
					this.stateListener.cancel()
				}
			}
		})
		setTimeout(() => {
			this.set({loading: false, rotating: true})
			setTimeout(() => {
				this.set({rotating: false})
			}, 700)
		}, 1)

		const logicUtils = await container.get(LOGIC_UTILS)

		page.set({container, logicUtils})
	}

	async function stopPage(
		page
	) {
		const {container}       = page.get()
		const cubeEventListener = await container.get(
			CUBE_EVENT_LISTENER)

		cubeEventListener.clearView('cube')
		DI.remove(container)
	}

	function move(
		component,
		positionsByAxisAndDir,
		axis,
		dir,
		switchToDefinitions
	) {
		let switchPositions = getSwitchArray(axis, dir, switchToDefinitions)

		movePositionPair(switchPositions[0], positionsByAxisAndDir)
		movePositionPair(switchPositions[1], positionsByAxisAndDir)

		component.fire('cubeAltered')
	}

	function movePositionPair(
		switchPosition,
		positionsByAxisAndDir
	) {
		const positionFrom = positionsByAxisAndDir[switchPosition.from.axis][switchPosition.from.dir]
		const positionTo   = positionsByAxisAndDir[switchPosition.to.axis][switchPosition.to.dir]

		const toDir  = positionTo.dir
		const toAxis = positionTo.axis

		positionTo.axis = positionFrom.axis
		positionTo.dir  = positionFrom.dir

		positionFrom.axis = toAxis
		positionFrom.dir  = toDir
	}

	function switchPoles(
		component,
		positionsByAxisAndDir,
		axis,
		dir
	) {
		let switchPositions = [{
			axis,
			dir
		},
			{
				axis,
				dir: dir === 1 ? -1 : 1
			}]

		const positionFrom = positionsByAxisAndDir[switchPositions[0].axis][switchPositions[0].dir]
		const positionTo   = positionsByAxisAndDir[switchPositions[1].axis][switchPositions[1].dir]

		const toDir      = positionFrom.dir
		positionTo.dir   = positionFrom.dir
		positionFrom.dir = toDir

		component.fire('cubeAltered')
	}

	function getSwitchArray(
		axis,
		dir,
		switchToDefinitions
	) {
		const switchPositionMap = {
			x: {
				1: 0,
				'-1': 1
			},
			y: {
				1: 2,
				'-1': 3
			},
			z: {
				1: 4,
				'-1': 5
			}
		}
		const to                = switchToDefinitions[switchPositionMap[axis][dir]]

		const [toAxis, toDir] = to
		const oppositeDir     = dir == 1 ? -1 : 1
		const toOppositeDir   = toDir == 1 ? -1 : 1

		return [{
			from: {
				axis,
				dir
			},
			to: {
				axis: toAxis,
				dir: toDir
			}
		}, {
			from: {
				axis,
				dir: oppositeDir
			},
			to: {
				axis: toAxis,
				dir: toOppositeDir
			}
		}]
	}

</script>
