<figure
		id="cube"
>
	<!--			on:click="toggleView(cubeView, event)"-->
	{#if poll}
	{#each positions as position, i}
	<div
			class="surface {loading ? 'loading' : ''} {rotating ? 'rotating' : ''}"
			id="s{i}"
			style="
            background-color: #{getColor(pFPsByAxisAndDir[position.axis][position.dir].color)};
              "
	>
		{#if !loading && !rotating}
		<header>
			{#if pFPsByAxisAndDir[position.axis][position.dir].outcome === 'A'}
			<CharacterButton
					character="A"
					fontSize="23"
					fontX="14.5"
					fontY="23"
					size="30"
					strokeWidth="0"
					styles="left: 1px; position: absolute; top: 0px;"
			></CharacterButton>
			{/if}
			{pFPsByAxisAndDir[position.axis][position.dir].factorPosition.factor.name}
			{#if pFPsByAxisAndDir[position.axis][position.dir].outcome === 'B'}
			<CharacterButton
					character="B"
					fontSize="23"
					fontX="14.5"
					fontY="23"
					size="30"
					strokeWidth="0"
					styles="right: 1px; position: absolute; top: 0px;"
			></CharacterButton>
			{/if}
		</header>
		{#if positionMode}
		<Positioner
				on:moveRight="moveRight(position.axis, position.dir, pFPsByAxisAndDir)"
				on:moveDown="moveDown(position.axis, position.dir, pFPsByAxisAndDir)"
				on:moveLeft="moveLeft(position.axis, position.dir, pFPsByAxisAndDir)"
				on:moveUp="moveUp(position.axis, position.dir, pFPsByAxisAndDir)"
				on:switchDir="switchDir(position.axis, position.dir, pFPsByAxisAndDir)"
		></Positioner>
		{/if}
		<p
				style="color: #{getTextColor(pFPsByAxisAndDir[position.axis][position.dir].color)};"
		>
			{pFPsByAxisAndDir[position.axis][position.dir].factorPosition.position.name}
		</p>
		{/if}
	</div>
	{/each}
	{/if}
</figure>
<style>

	/*
	@media (min-width: 321px) {

		figure#cube > div {
			font-size: 1.9em;
			line-height: 1.2em;
		}

	}

	@media (min-width: 376px) {
		figure#cube > div {
			font-size: 2.1em !important;
			line-height: 1.3em !important;
		}
	}
	 */

	#cube {
		height: 320px;
		margin: auto;
		position: relative;
		/*transform: rotateX(0deg) rotateY(-90deg);*/
		transform-style: preserve-3d;
		/*top: 50%;*/
		width: 320px;
	}

	#cube > div {
		/*border: 5px groove gray;*/
		border: 5px solid gray;
		border-radius: 10px;
		color: #000;
		/*font-size: 2.0em;*/
		font-size: 1.7em;
		font-weight: bold;
		/*height: 320px;*/
		height: 311px;
		/*line-height: 2.0em;*/
		line-height: 1.2em;
		position: absolute;
		/*width: 320px;*/
		width: 311px;
		/*
		height: 360px;
		width: 360px;
		padding: 20px;
		font-size: 1.8em;
		line-height: 2em;
		*/
	}


	#s0 {
		/*background: hsla(  0, 100%, 50%, 0.95);*/
		transform: rotateX(90deg) translateZ(160px) /*translateZ(200px)*/;
	}

	#s1 {
		transform: translateZ(160px) /*translateZ(200px)*/;
	}

	#s2 {
		transform: rotateY(90deg) translateZ(160px) /*translateZ(200px)*/;
	}

	#s3 {
		transform: rotateY(180deg) translateZ(160px) /*translateZ(200px)*/;
	}

	#s4 {
		transform: rotateY(-90deg) translateZ(160px) /*translateZ(200px)*/;
	}

	#s5 {
		transform: rotateX(-90deg) rotate(180deg) translateZ(160px) /*translateZ(200px)*/;
	}

	div {
		transition: width 700ms, height 700ms, transform 700ms;
		transition-timing-function: ease-out;
	}

	div.rotating {
		transform: rotateX(180deg) rotateY(180deg) !important;
	}

	div.loading {
		width: 1px !important;
		height: 1px !important;
	}

	/*footer,*/
	header {
		color: #fff;
		background-color: #000;
		font-size: 0.8em;
		font-weight: 500;
		height: 30px;
		line-height: 1em;
		overflow: hidden;
		position: relative;
		text-align: center;
		text-overflow: ellipsis;
		width: 100%;
		white-space: nowrap;
	}

	header {
		top: 0px
	}

	/*	footer {
			bottom: 0px;
			position: absolute;
		}*/

	p {
		margin: 0;
		margin-block-start: 0em;
		margin-block-end: 0em;
		padding: 0 10px;
		word-break: break-word;
	}

	/*	span {
			position: absolute;
			left: 55px;
			top: 7px;
		}

		span {
			display: inline-block;
		}*/

	.surface {
		position: relative;
	}

</style>

<script>
	import {
		clearView,
		mutationApi,
		setView
	}                                from '@votecube/cube-logic'
	import CharacterButton           from '../../common/control/button/CharacterButton.html'
	import {getDefaultCubePositions} from '../../helpers/cube'
	import {
		getColor,
		getTextColor
	}                                from '../../helpers/general'
	import Positioner                from './create/Positioner.html'

	export default {
		components: {
			CharacterButton,
			Positioner
		},
		computed: {
			horizontalLayout: ({verticalLayout}) => !verticalLayout
		},
		data() {
			return {
				loading: true,
				positions: getDefaultCubePositions(),
				rotating: false
			}
		},
		helpers: {
			getColor,
			getTextColor
		},
		methods: {
			moveDown(
				axis,
				dir,
				pFPsByAxisAndDir
			) {
				move(this, pFPsByAxisAndDir, axis, dir, [
					['y', 1], // x+
					['y', 1], // x-
					['x', -1], // y+
					['x', -1], // y-
					['x', -1], // z+
					['x', -1] // z-
				])
			},
			moveLeft(
				axis,
				dir,
				pFPsByAxisAndDir
			) {
				move(this, pFPsByAxisAndDir, axis, dir, [
					['z', -1], // x+
					['z', 1], // x-
					['z', -1], // y+
					['z', 1], // y-
					['y', 1], // z+
					['y', -1] // z-
				])
			},
			moveRight(
				axis,
				dir,
				pFPsByAxisAndDir
			) {
				move(this, pFPsByAxisAndDir, axis, dir, [
					['z', 1], // x+
					['z', -1], // x-
					['z', 1], // y+
					['z', -1], // y-
					['y', -1], // z+
					['y', 1] // z-
				])
			},
			moveUp(
				axis,
				dir,
				pFPsByAxisAndDir
			) {
				move(this, pFPsByAxisAndDir, axis, dir, [
					['y', -1], // x+
					['y', -1], // x-
					['x', 1], // y+
					['x', 1], // y-
					['x', 1], // z+
					['x', 1] // z-
				])
			},
			switchDir(
				axis,
				dir,
				pFPsByAxisAndDir
			) {
				switchPoles(this, pFPsByAxisAndDir, axis, dir)
			},
			/*			toggleView(
							cubeView,
							event
						) {
							if (!cubeView) {
								this.fire('select', event)
							}
						}*/
		},
		oncreate() {
			setView('cube')
			mutationApi.recompute()
			this.stateListener = this.on('state', ({changed, current, previous}) => {
				if (current.vote) {
					this.get().vote.changeMillis = 128
					if (this.stateListener) {
						this.stateListener.cancel()
					}
				}
			})
			setTimeout(() => {
				this.set({loading: false, rotating: true})
				setTimeout(() => {
					this.set({rotating: false})
				}, 700)
			}, 1)
		},
		ondestroy() {
			clearView('cube')
		}
		// onstate({changed, current}) {
		// 	if (!current.pFPsByAxisAndDir) {
		// 		return
		// 	}
		//
		// 	// let cubeElement
		// 	// if (changed.cubeView) {
		// 	// 	let options = {
		// 	// 		// x: 400,
		// 	// 		// y: 400,
		// 	// 		// duration: 700
		// 	// 	}
		// 	// 	// cubeElement = document.getElementById('cube')
		// 	// 	// cubeElement.classList.remove('cubeView')
		// 	// 	// if (current.cubeView) {
		// 	// 	// 	cubeElement.classList.add('cubeView')
		// 	// 	// 	// options.x = -options.x
		// 	// 	// 	// options.y = -options.y
		// 	// 	// }
		// 	// 	setTimeout(() => {
		// 	// 		transition(this, 'viewport', fade, options)
		// 	// 	})
		// 	// }
		//
		// 	if (changed.moveType) {
		// 		cubeElement = document.getElementById('cube')
		// 		cubeElement.classList.remove('toggle')
		// 		if (current.moveType === 'toggle') {
		// 			cubeElement.classList.add('toggle')
		// 		}
		// 	}
		// }
	}

	function move(
		component,
		pFPsByAxisAndDir,
		axis,
		dir,
		switchToDefinitions
	) {
		let switchPositions = getSwitchArray(axis, dir, switchToDefinitions)

		movePfpPair(switchPositions[0], pFPsByAxisAndDir)
		movePfpPair(switchPositions[1], pFPsByAxisAndDir)

		component.fire('cubeAltered')
	}

	function movePfpPair(
		switchPosition,
		pFPsByAxisAndDir
	) {
		const pfpFrom = pFPsByAxisAndDir[switchPosition.from.axis][switchPosition.from.dir]
		const pfpTo   = pFPsByAxisAndDir[switchPosition.to.axis][switchPosition.to.dir]

		const toDir  = pfpTo.dir
		const toAxis = pfpTo.axis

		pfpTo.axis = pfpFrom.axis
		pfpTo.dir  = pfpFrom.dir

		pfpFrom.axis = toAxis
		pfpFrom.dir  = toDir
	}

	function switchPoles(
		component,
		pFPsByAxisAndDir,
		axis,
		dir
	) {
		let switchPositions = [{
			axis,
			dir
		},
			{
				axis,
				dir: dir === 1 ? -1 : 1
			}]

		const pfpFrom = pFPsByAxisAndDir[switchPositions[0].axis][switchPositions[0].dir]
		const pfpTo   = pFPsByAxisAndDir[switchPositions[1].axis][switchPositions[1].dir]

		const toDir = pfpFrom.dir
		pfpTo.dir   = pfpFrom.dir
		pfpFrom.dir = toDir

		component.fire('cubeAltered')
	}

	function getSwitchArray(
		axis,
		dir,
		switchToDefinitions
	) {
		const switchPositionMap = {
			x: {
				1: 0,
				'-1': 1
			},
			y: {
				1: 2,
				'-1': 3
			},
			z: {
				1: 4,
				'-1': 5
			}
		}
		const to                = switchToDefinitions[switchPositionMap[axis][dir]]

		const [toAxis, toDir] = to
		const oppositeDir     = dir == 1 ? -1 : 1
		const toOppositeDir   = toDir == 1 ? -1 : 1

		return [{
			from: {
				axis,
				dir
			},
			to: {
				axis: toAxis,
				dir: toDir
			}
		}, {
			from: {
				axis,
				dir: oppositeDir
			},
			to: {
				axis: toAxis,
				dir: toOppositeDir
			}
		}]
	}

</script>
