{#each voteDims as voteDim, i}
<section
		on:mousedown="moveStart(voteDims, i, event)"
		on:mouseup="moveEnd(movingVoteDim, vote, voteDims, i, event)"
		on:touchend="moveEnd(movingVoteDim, vote, voteDims, i, event)"
		on:touchstart="touchStart(voteDims, i, event)"
>
	{#if showPosition(voteDim, movingVoteDim, movingVoteDimDelta)}
	<figure
			class:isB="isB(voteDim, delta)"
			factorIndex="{i}"
			id="factor_{i}"
			style="{factorPosition(voteDim, movingVoteDimDelta)}
					 {transitionStyle(showTransition)}"
			transition:fly='{x: flyX(voteDim), duration: 700}'
	>
		<!--
			transition:fade
			-->
		{#if sideMatch(voteDims[i], 1, switchingDir)}
		<var
				class="factor A
					{factorHighlight(movingVoteDim, i, movingVoteDimDelta)}"
				style="background-color: #{getColor(delta, poll, voteDim.axis)};"
		>
			<!--
				id="factor_{i}_A"
				-->
			<!-- TODO: if the default starting value becomes dynamic change this -->
			<header>
				<CharacterButton
						character="A"
						fontSize="20"
						fontX="12"
						fontY="19"
						size="24"
						strokeWidth="1"
						styles="left: 1px; position: absolute; top: -1px;"
				></CharacterButton>
				{getSideText(delta, 'confirm', poll, voteDim.axis, 1)}
				{#if i}
				<MoveButton
						on:selectStart="addOrRemove(-1, event)"
						classes="right"
						size="19"
						styles="left: 24px; position: absolute; top: -1.5px"
				></MoveButton>
				<MoveButton
						on:selectStart="upStart(i, event)"
						classes="up"
						size="19"
						styles="right: 24px; position: absolute; top: -2px"
				></MoveButton>
				{/if}
			</header>
			<p>
				{getSideText(delta, 'cube', poll, voteDim.axis, 1)}
			</p>
		</var>
		{/if}
		{#if sideMatch(voteDims[i], -1, switchingDir)}
		<!--
		transition:fly='{x: -200, duration: 1000}'
		-->
		<var
				class="factor B
					{factorHighlight(movingVoteDim, i, movingVoteDimDelta)}"
				style="background-color: #{getColor(delta, poll, voteDim.axis)};"
		>
			<!--
				id="factor_{i}_B"
				-->
			<header>
				{getSideText(delta, 'confirm', poll, voteDim.axis, -1)}
				<CharacterButton
						character="B"
						fontSize="20"
						fontX="12"
						fontY="19"
						size="24"
						strokeWidth="1"
						styles="right: 1px; position: absolute; top: -1px;"
				></CharacterButton>
				{#if i}
				<MoveButton
						on:selectStart="addOrRemove(-1, event)"
						classes="right"
						size="19"
						styles="left: 24px; position: absolute; top: -1.5px"
				></MoveButton>
				<MoveButton
						on:selectStart="upStart(i, event)"
						classes="up"
						size="19"
						styles="right: 24px; position: absolute; top: -2px"
				></MoveButton>
				{/if}
			</header>
			<p>
				{getSideText(delta, 'cube', poll, voteDim.axis, -1)}
			</p>
			<!--
					<footer>
						{getSideText(delta, 'confirm', poll, voteDim.axis, -1)}
					</footer>
					-->
		</var>
		{/if}
	</figure>
	{:elseif showPlaceholder(removeCount, removeDoneCount)}
	<var
			class="placeholder"
	>

		<MoveButton
				on:selectStart="addOrRemove(1, event)"
				size="19"
				styles="left: 32px; position: absolute; top: 42px"
		></MoveButton>
	</var>
	{/if}
	{#if showMovePlaceholder(movingVoteDim, i, movingVoteDimDelta)}
	<figure>
		<var
				class="placeholder"
		>
		</var>
	</figure>
	{/if}
</section>
{/each}

<style>

	@media (min-width: 321px) {
		header + p {
			font-size: 1.1em;
			line-height: 1.1em;
		}
	}

	@media (min-width: 376px) {
		header + p {
			font-size: 1.15em !important;
			line-height: 1.15em !important;
		}
	}

	figure {
		height: 100px;
		position: relative;
		transform-style: preserve-3d;
	}

	var {
		border-radius: 5px;
		height: 100px;
		position: absolute;
		width: 100%;
	}

	.isB {
		transform: rotateY(180deg);
	}

	var.factor {
		border: 3px solid gray;
	}

	var.factor.highlighted {
		border: 5px dashed red;
	}

	var.placeholder {
		border: 1px dotted gray;
	}

	/*	footer {
			bottom: 0px;
		}*/

	/*footer,*/
	header {
		color: #fff;
		background-color: #000;
		font-size: 1.2em;
		font-weight: 500;
		line-height: 1.2em;
		overflow: hidden;
		position: absolute;
		text-align: center;
		text-overflow: ellipsis;
		width: 100%;
		white-space: nowrap;
	}

	header {
		top: 0px
	}

	header + p {
		margin: 0px;
		padding: 3px;
		position: absolute;
		top: 21px;
	}

	/*	nav {
			color: #000;
			font-size: 5em;
			height: 20px;
			left: 50%;
			margin-right: -50%;
			position: absolute;
			top: calc(50% - 10px);
			transform: translate(-50%, -50%);
			width: 20%;
		}*/

	p {
		color: #000;
		font-size: 1.05em;
		line-height: 1.05em;
		margin-block-start: 0em;
		margin-block-end: 0em;
		padding: 7px 5px 14px 5px;
	}

	section {
		height: 100px;
	}

	.A {
		transform: translateZ(5px);
	}

	/*transform: rotateY(180deg) translateY(-100px) translateZ(5px);*/
	.B {
		transform: rotateY(180deg) translateZ(5px);
	}

</style>

<script>
	import {TOUCH}                   from '@votecube/cube-logic'
	import {fly}                     from 'svelte-transitions'
	import AddRemoveButton           from '../../common/control/button/AddRemoveButton.html'
	import CharacterButton           from '../../common/control/button/CharacterButton.html'
	import MoveButton                from '../../common/control/button/MoveButton.html'
	import SwapButton                from '../../common/control/button/SwapButton.html'
	import {transition}              from '../../helpers/animation'
	import {
		getColor,
		getSideText
	}                                from '../../helpers/cube'
	import {getVoteDimsInValueOrder} from '../../helpers/factorRanking'
	import store                     from '../../store'
	import DirectionSelector         from '../vote/DirectionSelector.html'

	export default {
		components: {
			AddRemoveButton,
			CharacterButton,
			DirectionSelector,
			MoveButton,
			SwapButton
		},
		data() {
			return {
				factorOrderDelta: 0,
				/*
				// Dynamically assigned transition fly values is applied too late
				// for the slide in animation to work, so animating other transitions
				// manually
				factorFlySettings: {
					x: -200
				},
				*/
				movingVoteDimDelta: 0,
				removeCount: 0,
				removeDoneCount: 0,
				showTransition: true,
				switchingDir: false
			}
		},
		helpers: {
			factorHighlight(
				movingVoteDim,
				index,
				movingVoteDimDelta
			) {
				if (!movingVoteDim || index === movingVoteDim.index) {
					return ''
				}

				const factorInfo = getFactorInfoAtCoords(
					movingVoteDim.originalX, movingVoteDim.pageY, movingVoteDim.index)

				return factorInfo && factorInfo.factorIndex === index ? 'highlighted' : ''
			},
			factorPosition(
				movingVoteDim
			) {
				if (!movingVoteDim.moving || !movingVoteDim.dir) {
					return ''
				}
				// let left = movingVoteDim.originalTopLeftX
				let top = movingVoteDim.pageY
				if (movingVoteDim.offset) {
					top -= movingVoteDim.offset.y
				}
				const xChange    = movingVoteDim.originalX - movingVoteDim.pageX
				const absXChange = Math.abs(xChange)
				const absYChange = Math.abs(movingVoteDim.originalY - movingVoteDim.pageY)

				// console.log('dX: ' + xChange
				// 	+ '\tabsDX: ' + absXChange
				// 	+ '\tabsDY: ' + absYChange)

				if (movingVoteDim.index > 0
					&& xChange > 0
					&& absXChange > absYChange
				) {
					// left = movingVoteDim.pageX
					// if (movingVoteDim.offset) {
					// 	left -= movingVoteDim.offset.x
					// }
					if (movingVoteDim.originalTopLeftY) {
						top = movingVoteDim.originalTopLeftY
					}
					// 	console.log('-\tleft: ' + left + '\ttop: ' + top)
					// } else {
					// 	console.log('|\tleft: ' + left + '\ttop: ' + top)
				}
				// left: ${left}px;
				return `position: absolute;
					top: ${top - 125}px;
					width: ${movingVoteDim.width}px;
					z-index: 5000;
					`
			},
			flyX: (
				voteDim
			) => voteDim.dir === 1 ? -200 : 200,
			getColor,
			getSideText,
			isB: (
				voteDim
			) => voteDim.dir === -1,
			showPlaceholder(
				removeCount,
				removeDoneCount
			) {
				return removeCount === removeDoneCount
			},
			showMovePlaceholder(
				movingVoteDim,
				index,
				movingVoteDimDelta
			) {
				return movingVoteDim && movingVoteDim.moving && index === movingVoteDim.index
			},
			showPosition:
				voteDim => {
					return !!voteDim.value
					// || (movingVoteDim === voteDim
					// 	&& movingVoteDim.originalX - movingVoteDim.pageX < -10)
				},
			/*			showSwap: (
							voteDims,
							index
						) => {
							if (index === 0) {
								return false
							}
							return voteDims[index].dir
						}*/
			sideMatch: (
				voteDim,
				dir,
				switchingDir
			) => switchingDir || dir === voteDim.dir,
			transitionStyle: (
				showTransition
			) => showTransition ? 'transition: transform 1000ms linear;' : ''
		},
		methods: {
			moveEnd(
				movingVoteDim,
				vote,
				voteDims,
				index,
				event,
			) {
				// let nowMillis = new Date().getTime()
				try {
					stopMoveEventListening(
						// this, movingVoteDim
					)

					let {
						    // lastMoveEnd,
						    lastMoveStart,
						    // lastClickMillis
					    } = this.get()

					// if (lastMoveEnd && time - lastMoveEnd.time < 500) {
					// 	return
					// }

					if (!lastMoveStart
						||
						// Already added the factor in
						!movingVoteDim
					// || nowMillis - lastClickMillis < 100
					) {
						return
					}

					const usefulEvent = event.changedTouches && event.changedTouches[0]
						? event.changedTouches[0] : event
					const factorInfo  = getFactorInfoAtCoords(voteDims[index].originalX, usefulEvent.pageY, index)
					if (factorInfo && factorInfo.factorIndex >= 0) {
						index = factorInfo.factorIndex
					}

					let dx      = movingVoteDim.pageX - movingVoteDim.originalX
					let dy      = movingVoteDim.pageY - movingVoteDim.originalY
					const absDx = Math.abs(dx)
					const absDy = Math.abs(dy)

					// console.log('moving: ' + index)
					// console.log(event)

					const originalIndex     = lastMoveStart.index
					const upButtonClickMove = lastMoveStart.move
					const addOrRemove       = lastMoveStart.addOrRemove
					if (!upButtonClickMove && originalIndex === index) {
						singleFactorChange(
							absDx, absDy, addOrRemove, dy, index, originalIndex,
							upButtonClickMove, vote, voteDims, this)
					} else {
						multiFactorChange(absDx, absDy, dy, index,
							originalIndex, upButtonClickMove, vote, voteDims, this)
					}
				} finally {
					stopVoteDimMovement(this, movingVoteDim)
				}
			},
			moveStart(
				voteDims,
				index,
				event
			) {
				// let millis        = new Date().getTime()
				let time = new Date().getTime()

				// let {
				// 	    lastClickMillis
				//     } = this.get()
				//
				// if (time - lastClickMillis < 100) {
				// 	return
				// }

				// const {lastMoveStart} = this.get()
				//
				// if (lastMoveStart && time - lastMoveStart.time < 500) {
				// 	return
				// }

				// {
				// index,
				// millis,
				// x: 0,
				// y: 0
				// }
				// populateStartCoords(event, lastMoveStart)

				const movingVoteDim = voteDims[index]

				const usefulEvent    = event.touches ? event.touches[0] : event
				movingVoteDim.index  = index
				// Offset is only recorded once
				movingVoteDim.offset = getInElementOffset(usefulEvent)
				positionMovingVoteDim(movingVoteDim, usefulEvent)
				movingVoteDim.originalX = movingVoteDim.pageX
				movingVoteDim.originalY = movingVoteDim.pageY

				const move        = event.factorButtonMove
				const addOrRemove = event.factorButtonAddOrRemove
				if (addOrRemove || move) {
					movingVoteDim.moving = true
					// usefulEvent.target.parentNode.parentNode.parentNode.clientWidth
				} else {
					// movingVoteDim.width = usefulEvent.target.clientWidth
				}
				movingVoteDim.width = 320

				this.set({
					lastMoveStart: {
						index: event.factorButtonMove ? event.factorButtonIndex : index,
						move,
						addOrRemove,
						time
					},
					movingVoteDim
				})
				incMovingDelta(this)

				if (!addOrRemove) {
					document.addEventListener('mousemove', getFactorMoveHandler(this))
					document.addEventListener('touchmove', getFactorMoveHandler(this))
					voteDims[index].moving = true
				}
				// console.log('moveStart: ' + index)
				// console.log(event)
				// console.log(lastMoveStart)
			},
			addOrRemove(
				dir,
				event
			) {
				event.factorButtonAddOrRemove = dir
			},
			touchStart(
				voteDims,
				index,
				event
			) {
				// https://developer.mozilla.org/en-US/docs/Web/API/Touch_events/Supporting_both_TouchEvent_and_MouseEvent
				event.preventDefault()
				this.moveStart(voteDims, index, event)
			},
			/*			up(
							vote,
							voteDims,
							index,
							event
						) {
							event.preventDefault()
							// moveFactorUp(voteDims, vote, index, index - 1, this)
							move(index, {y: -100, delay: 400}, page)
						},*/
			upStart(
				index,
				event
			) {
				event.factorButtonMove  = true
				event.factorButtonIndex = index - 1
				setTimeout(() => {
					// move(index - 1, {y: 100, delay: 50}, this)
					move(index - 1, {y: 100}, this)
					move(index, {y: -100}, this)
				}, 100)
			}
		},
		// oncreate() {
		/*
		this.stateListener = this.on('state', ({changed, current, previous}) => {
			if (previous.voteDims.length
				|| !current.voteDims.length) {
				return
			}
			const [_, secondFactor, thirdFactor] = current.voteDims
			let adjusted                         = false
			if (!secondFactor.value && secondFactor.dir) {
				adjusted         = true
				secondFactor.dir = 0
			}
			if (!thirdFactor.value && thirdFactor.dir) {
				adjusted        = true
				thirdFactor.dir = 0
			}
			if (adjusted) {
				this.fire('directionCorrected')
			}
		})
		 */
		// },
		// ondestroy() {
		// 	// this.stateListener.cancel()
		// 	this.set({movingVoteDim: null})
		// },
		store: () => store,
		transitions: {
			// fade,
			fly
		}
	}

	function getAlternateIndex(
		absDy,
		dy,
		originalIndex
	) {
		switch (originalIndex) {
			case 0: {
				if (dy > 0) {
					if (absDy < 200) {
						return 1
					} else {
						return 2
					}
				}
				break
			}
			case 1: {
				if (dy > 0) {
					return 2
				} else {
					return 0
				}
				break
			}
			case 2: {
				if (dy < 0) {
					if (absDy < 200) {
						return 1
					} else {
						return 0
					}
				}
				break
			}
		}
		return originalIndex
	}

	function singleFactorChange(
		absDx,
		absDy,
		addOrRemove,
		dy,
		index,
		originalIndex,
		upButtonClickMove,
		vote,
		voteDims,
		page
	) {
		if (!addOrRemove && absDx < 10 && absDy < 10) {
			changeFactorPosition(voteDims, index, page)
		}
		// Change to 1 factor only
		else if (addOrRemove || absDx - 10 > absDy) {
			pauseRotation(page)
			const numMoved = addOrRemoveAFactor(
				voteDims, index, addOrRemove ? addOrRemove : dx, page)
			if (addOrRemove === 1) {
				setTimeout(() => {
					move(index, {x: -200, duration: 700}, page)
					if (numMoved === 2) {
						setTimeout(() => {
							move(index - 1, {x: -200, duration: 700}, page)
						}, 50)
					}
				})
			}
		} else if (absDy >= 10 && absDx * 2 < absDy) {
			const index = getAlternateIndex(absDy, dy, originalIndex)
			if (index !== originalIndex) {
				multiFactorChange(absDx, absDy, dy, index,
					originalIndex, upButtonClickMove, vote, voteDims, page)
			}
			// Else a no-op
		}
		// Else a no-op
	}

	function multiFactorChange(
		absDx,
		absDy,
		dy,
		index,
		originalIndex,
		upButtonClickMove,
		vote,
		voteDims,
		page
	) {
		// Change across multiple items
		if (upButtonClickMove || absDy - 10 > absDx) {
			if (!voteDims[originalIndex].dir
				|| !voteDims[index].dir) {
				return
			}
			pauseRotation(page)
			// Move items
			if (upButtonClickMove || dy > 0) {
				moveFactorDown(voteDims, vote, originalIndex, index, page)
			} else {
				moveFactorUp(voteDims, vote, originalIndex, index, page)
			}
		}
		/* Not implemented
		else if (moveCoords.moveY) {
			// Add or remove items
			if (moveCoords.yBy <= 0) {
				removeFactors(voteDims, this)
			} else {
				addFactors(voteDims, lastMoveStart.index, index, this)
			}
		}
		*/
		// Else a no-op
	}

	function addRemoveFactor(
		voteDims,
		index,
		page
	) {
		page.get().vote.changeMillis = 550
		// moveInOrOut(index, page)
		if (voteDims[index].dir) {
			scheduleFactorPlaceholder(page)
			if (index === 1) {
				setDir(voteDims, 2, 0, page)
				// adjustRanking(voteDims, 1, 1, page, false)
			}
			setDir(voteDims, index, 0, page)
			adjustRanking(voteDims, index, 0, page)
		} else {
			if (index === 2) {
				setDir(voteDims, 1, 1, page)
				adjustRanking(voteDims, 1, 1, page, false)
			}
			setDir(voteDims, index, 1, page)
			adjustRanking(voteDims, index, 1, page)
		}
	}

	function setDir(
		voteDims,
		index,
		dir,
		page,
		adjustRanking = false
	) {
		voteDims[index].dir = dir
		if (adjustRanking) {
			page.fire('rankingAdjusted')
		}
	}

	function adjustRanking(
		voteDims,
		index,
		dir,
		page,
		doAdjust = true
	) {
		const [firstFactor, secondFactor, thirdFactor] = voteDims
		switch (index) {
			case 0: {
				// firstFactor.dir = dir
				// Don't have to worry about dir === 0 - 1st factor cannot have it as such
				if (
					// If there the 1st factor is present in vote
					factorsAt(100, 0, 0, voteDims)
					// Or its another standard distribution
					|| factorsAt(66, 34, 0, voteDims)
					|| factorsAt(55, 30, 15, voteDims)
				) {
					// Nothing to do, just change direction
				} else {
					// set default distribution
					firstFactor.value  = 55
					secondFactor.value = 30
					thirdFactor.value  = 15
					// Default 2nd factor to positive direction
					// secondFactor.dir   = 1
					// Default 3rd factor to positive direction
					// thirdFactor.dir    = 1
				}
				break
			}
			case 1: {
				// secondFactor.dir = dir
				// If the 2nd factor is being removed from the vote
				if (dir === 0) {
					firstFactor.value  = 100
					secondFactor.value = 0
					thirdFactor.value  = 0
					// thirdFactor.dir    = 0
					break
				}
				// Otherwise the 2nd factor is now present in the vote
				if (
					factorsAt(55, 30, 15, voteDims)
					|| factorsAt(66, 34, 0, voteDims)) {
					// Factors are already at reserved values, no need to adjust values
				} else if (
					factorsAt(100, 0, 0, voteDims)
				) {
					// Add the second factor
					firstFactor.value  = 66
					secondFactor.value = 34
				} else {
					// set default distribution
					firstFactor.value  = 55
					secondFactor.value = 30
					thirdFactor.value  = 15
					// Default 3rd factor to positive direction
					// thirdFactor.dir    = 1
				}
				break
			}
			case 2: {
				// thirdFactor.dir = dir
				// If the 3rd factor is being removed from the vote
				if (dir === 0) {
					firstFactor.value  = 66
					secondFactor.value = 34
					thirdFactor.value  = 0
					break
				}
				// Otherwise the 3rd factor is now present in the vote
				if (
					factorsAt(55, 30, 15, voteDims)
				) {
					// Factors are already at reserved values, no need to adjust values
				} else {
					// set default distribution
					firstFactor.value  = 55
					secondFactor.value = 30
					thirdFactor.value  = 15
				}
				break
			}
			default:
				return
		}
		if (doAdjust) {
			page.fire('rankingAdjusted')
		}
	}

	function moveDownOne(
		index,
		page,
		duration = 400
	) {
		move(index, {y: -100, duration}, page)
		return {
			move: 1,
			moved: [index, index + 1]
		}
	}

	function moveDownTwo(
		index,
		page
	) {
		move(index, {y: -200, duration: 800}, page)
		return {
			move: 2,
			moved: [index, index + 2]
		}
	}

	function moveUpOne(
		index,
		page,
		duration = 400
	) {
		move(index, {y: 100, duration}, page)
	}

	function moveUpTwo(
		index,
		page
	) {
		move(index, {y: 200, duration: 800}, page)
	}

	/*
		function moveInAndOut(
			index,
			outcome,
			page
		) {
			move(index, {x: -300}, page, '_' + outcome)
		}
	*/

	function move(
		index,
		options,
		page,
		// suffix = ''
	) {
		transition(
			page,
			'factor_' + index // + suffix
			, fly,
			options
		)
	}

	function setFactorOrder(
		voteDims,
		index,
		delta,
		vote,
		page,
		oldHigherFactor,
		oldLowerFactor,
		deltaIndex
	) {
		const [firstFactor, secondFactor, thirdFactor]
			      = voteDims
		let oldHigherDir
		let oldHigherValue
		if (!oldHigherFactor) {
			switch (index) {
				case 0: {
					// Only Down arrow can be pressed, no need to check delta
					deltaIndex      = 0
					oldHigherFactor = firstFactor
					oldLowerFactor  = secondFactor
					break
				}
				case 1: {
					if (delta > 0) {
						deltaIndex      = 0
						oldHigherFactor = firstFactor
						oldLowerFactor  = secondFactor
					} else {
						deltaIndex      = 1
						oldHigherFactor = secondFactor
						oldLowerFactor  = thirdFactor
					}
					break
				}
				case 2: {
					// Only Up arrow can be pressed, no need to check delta
					deltaIndex      = 1
					oldHigherFactor = secondFactor
					oldLowerFactor  = thirdFactor
					break
				}
			}
		}
		oldHigherDir          = oldHigherFactor.dir
		oldHigherValue        = oldHigherFactor.value
		// oldHigherFactor.dir   = oldLowerFactor.dir
		oldHigherFactor.value = oldLowerFactor.value
		// oldLowerFactor.dir    = oldHigherDir
		oldLowerFactor.value  = oldHigherValue

		page.set({factorOrderDelta: page.get().factorOrderDelta + 1})

		adjustRanking(getVoteDimsInValueOrder(vote), deltaIndex, oldHigherDir, page)
	}

	function factorsAt(
		firstFactorValue,
		secondFactorValue,
		thirdFactorValue,
		voteDims
	) {
		return voteDims[0].value === firstFactorValue
			&& voteDims[1].value === secondFactorValue
			&& voteDims[2].value === thirdFactorValue
	}

	function changeFactorPosition(
		voteDims,
		index,
		page
	) {
		if (!voteDims[index].dir) {
			// If the factor isn't shown don't change position
			return
		}
		// const voteDim = voteDims[index]
		let direction = -1
		if (voteDims[index].dir < 0) {
			direction = 1
		}
		const lastTimeoutHandle = page.get().timeoutHandle
		if (lastTimeoutHandle) {
			clearTimeout(lastTimeoutHandle)
		}
		page.set({switchingDir: true})
		setTimeout(() => {
			page.get().vote.changeMillis = 1000
			setDir(voteDims, index, direction, page, true)
			// adjustRanking(voteDims, index, direction, page)
			page.set({
				timeoutHandle: setTimeout(() => {
					page.set({switchingDir: false})
				}, 1000)
			})
		})
	}

	function addOrRemoveAFactor(
		voteDims,
		index,
		addOrRemove,
		page
	) {
		if (index === 0) {
			// Cannot add or remove the first factor
			return 0
		}
		const [_, secondFactor, thirdFactor] = voteDims

		let numMoved    = 1
		const direction = voteDims[index].dir
		if (addOrRemove < 0) {
			// remove
			if (!direction) {
				// Don't remove if it's already removed
				return 0
			}

			// moveInAndOut(index, direction === 1 ? 'A' : 'B', page)
			// moveInOrOut(index, page)
			scheduleFactorPlaceholder(page)
			// if (index == 1 && thirdFactor.dir) {
			// 	adjustRanking(voteDims, 2, 0, page, false)
			// }
			page.get().vote.changeMillis = 550
			setDir(voteDims, index, 0, page)
			if (index === 1 && thirdFactor.dir) {
				setDir(voteDims, 2, 0, page)
				numMoved = 2
				// adjustRanking(voteDims, 1, 0, page)
				// } else {
			}
			adjustRanking(voteDims, index, 0, page)
		} else {
			// add
			if (direction) {
				// Don't add if it's already added
				return 0
			}

			// moveInAndOut(index, 'A', page)
			// moveInOrOut(index, page)
			// if (index == 2 && !secondFactor.dir) {
			// 	adjustRanking(voteDims, 1, 1, page, false)
			// }
			page.get().vote.changeMillis = 550
			if (index === 2 && !secondFactor.dir) {
				setDir(voteDims, 1, 1, page)
				adjustRanking(voteDims, 1, 1, page, false)
				numMoved = 2
			}
			setDir(voteDims, index, 1, page)
			adjustRanking(voteDims, index, 1, page)
		}

		return numMoved
	}

	function moveFactorUp(
		voteDims,
		vote,
		originalIndex,
		newIndex,
		page
	) {
		switch (originalIndex) {
			// Started the move from 1st Factor
			case 0: {
				// Not possible, nothing to do
				return
			}
			// Started the move from 2nd Factor
			case 1: {
				onMove(1, [1, 0], page)
				page.get().vote.changeMillis = 200
				setFactorOrder(
					voteDims,
					originalIndex,
					1,
					vote,
					page
				)
				moveDownOne(1, page)
				break
			}
			// Started the move from 3rd Factor
			case 2: {
				if (newIndex == 1) {
					onMove(1, [2, 1], page)
					page.get().vote.changeMillis = 200
					setFactorOrder(
						voteDims,
						originalIndex,
						1,
						vote,
						page
					)
					moveDownOne(2, page)
				} else {
					onMove(2, [2, 0], page)
					page.get().vote.changeMillis = 600
					setFactorOrder(
						voteDims,
						originalIndex,
						1,
						vote,
						page,
						voteDims[0],
						voteDims[2],
						0
					)
					moveDownTwo(2, page)
				}
				break
			}
		}
	}

	function moveFactorDown(
		voteDims,
		vote,
		originalIndex,
		newIndex,
		page
	) {
		switch (originalIndex) {
			// Started the move from 1st Factor
			case 0: {
				if (newIndex == 1) {
					onMove(1, [0, 1], page)
					page.get().vote.changeMillis = 200
					setFactorOrder(
						voteDims,
						originalIndex,
						-1,
						vote,
						page
					)
					moveUpOne(0, page)
				} else {
					onMove(2, [0, 2], page)
					page.get().vote.changeMillis = 600
					setFactorOrder(
						voteDims,
						originalIndex,
						-1,
						vote,
						page,
						voteDims[0],
						voteDims[2],
						0
					)
					moveUpTwo(0, page)
				}
				break
			}
			// Started the move from 2nd Factor
			case 1: {
				onMove(1, [1, 2], page)
				page.get().vote.changeMillis = 200
				setFactorOrder(
					voteDims,
					originalIndex,
					-1,
					vote,
					page
				)
				moveUpOne(1, page)
				break
			}
			// Started the move from 3rd Factor
			case 2: {
				// Not possible, nothing to do
				return null
			}
		}
	}

	function getFactorInfoAtCoords(
		x,
		y,
		factorIndexToExclude
	) {
		if (!x || !y) {
			return null
		}
		let nodes
		if (document.msElementsFromPoint) {
			nodes = document.msElementsFromPoint(
				x,
				y
			)
		} else {
			nodes = document.elementsFromPoint(
				x,
				y
			)
		}

		if (!nodes || !nodes.forEach) {
			return null
		}

		let matchingFactorInfo
		nodes.forEach(
			node => {
				const factorInfo = getFactorInfo(node)
				if (!matchingFactorInfo && factorInfo
					&& factorInfo.factorIndex !== factorIndexToExclude) {
					matchingFactorInfo = factorInfo
				}
			})

		return matchingFactorInfo
	}

	function getFactorInfo(
		node
	) {
		if (!node) {
			return null
		}
		while (node.getAttribute
		&& !node.getAttribute('factorIndex')
		&& node.parentNode) {
			node = node.parentNode
		}
		if (node.getAttribute
			&& node.getAttribute('factorIndex')) {
			return {
				factorTd: node,
				factorIndex: parseInt(node.getAttribute('factorIndex'))
			}
		}
		return null
	}

	function getFactorMoveHandler(
		page
	) {
		onFactorMove.page = page

		return onFactorMove
	}

	function onFactorMove(
		event // event
	) {
		const touches = event.touches

		// Only perform rotation if one touch or mouse (e.g. still scale with pinch and zoom)
		if (!TOUCH || !(touches && touches.length > 1)) {
			try {
				event.preventDefault()
			} catch (error) {
				// console.log(error)
			}

			let position = touches ? touches[0] : event
			// Get touch co-ords
			// ev.originalEvent.touches ? ev = ev.originalEvent.touches[0] : null
			// dispatch 'move-viewport' event
			const page          = onFactorMove.page
			const movingVoteDim = page.get().movingVoteDim
			positionMovingVoteDim(movingVoteDim, position)

			if (movingVoteDim.moving && !movingVoteDim.dir
				&& movingVoteDim.originalX - movingVoteDim.pageX < -10) {
				stopMoveEventListening(
					// page, movingVoteDim
				)
				// stopping movement before adding factor to get the slide in animation
				stopVoteDimMovement(page, movingVoteDim)
				setTimeout(() => {
					addRemoveFactor(page.get().voteDims, movingVoteDim.index, page)
				})
			}
			incMovingDelta(page)
		}
	}

	function stopMoveEventListening(
		// page,
		// movingVoteDim
	) {
		document.removeEventListener('mousemove', onFactorMove)
		document.removeEventListener('touchmove', onFactorMove)
	}

	function stopVoteDimMovement(
		page,
		movingVoteDim,
		// index,
		// time
	) {
		if (movingVoteDim) {
			movingVoteDim.moving = false
		}
		page.set({
			// lastMoveEnd: {
			// 	index,
			// 	time
			// },
			movingVoteDim: null,
		})
		incMovingDelta(page)
	}

	function positionMovingVoteDim(
		movingVoteDim,
		position
	) {
		movingVoteDim.pageX = position.pageX
		movingVoteDim.pageY = position.pageY
	}

	function scheduleFactorPlaceholder(
		page
	) {
		page.set({removeCount: page.get().removeCount + 1})
		setTimeout(() => {
			page.set({removeDoneCount: page.get().removeDoneCount + 1})
		}, 701)
	}

	function getInElementOffset(
		event
	) {
		// event (directly for mouse/via touches[0] for touch)
		// 	pageX/Y gives the cursor position on screen at mouse/touchDown

		const cursorPositionX = event.pageX
		const cursorPositionY = event.pageY

		let factorInfoAtCoords = getFactorInfoAtCoords(
			cursorPositionX, cursorPositionY, -1)

		if (!factorInfoAtCoords) {
			return null
		}

		// target (directly on event for mouse/via touches[0].target for touch)
		// 	has the information for the top left corner of the element:

		const boundingClientRect = event.target.getBoundingClientRect()
		const elemTopLeftCornerX = boundingClientRect.left
		const elemTopLeftCornerY = boundingClientRect.top


		// factorPosition places the element based on the top left corner
		// so need to know the offset by which to move the picture to top and left:

		return {
			// topLeft: {
			// 	x: elemTopLeftCornerX,
			// 	y: elemTopLeftCornerY,
			// },
			x: cursorPositionX - elemTopLeftCornerX,
			y: cursorPositionY - elemTopLeftCornerY
		}

		// Whereever the cursor is at we need to substract the offsets from it
		// to show the element.
	}

	function pauseRotation(
		page
	) {
		page.set({showTransition: false})
		setTimeout(() => {
			page.set({showTransition: true})
		}, 801)
	}

	function onMove(
		move,
		moved,
		page
	) {
		page.store.set({
			cardMove: {
				move,
				moved
			}
		})
	}

	function incMovingDelta(page) {
		page.set({movingVoteDimDelta: page.get().movingVoteDimDelta + 1})
		setTimeout(() => {
			page.set({movingVoteDimDelta: page.get().movingVoteDimDelta + 1})
			setTimeout(() => {
				page.set({movingVoteDimDelta: page.get().movingVoteDimDelta + 1})
			}, 100)
		})
	}

</script>
