{#if poll}
{#each voteFactors as voteFactor, i}
<section
		on:mousedown="moveStart(voteFactors, i, event, logic)"
		on:mouseup="moveEnd(movingVoteFactor, vote, voteFactors, i, event, logic)"
		on:touchend="moveEnd(movingVoteFactor, vote, voteFactors, i, event, logic)"
		on:touchstart="touchStart(voteFactors, i, event)"
		id="factorPlace_{i}"
>
	{#if showPosition(voteFactor, movingVoteFactor, movingVoteFactorDelta)}
	<figure
			class="factorFigure"
			class:isB="isB(voteFactor, delta)"
			class:removingFactor="removeCount && !voteFactor.outcome"
			factorNumber="{i}"
			id="factor_{i}"
			style="{factorPosition($windowWidth, voteFactor, movingVoteFactorDelta)}
					 {transitionStyle(showTransition)}"
			in:fly='{x: flyX(voteFactor), duration: 700}'
	>
		<!--
			transition:fade
			-->
		{#if sideMatch(voteFactor, 'A', switchingOutcome)}
		<var
				class="factor A
					{factorHighlight(movingVoteFactor, i, movingVoteFactorDelta, logic)}"
				style="background-color: #{getColor(poll.factors[voteFactor.factorNumber].color, logicUtils, delta)};"
		>
			<!--
				id="factor_{i}_A"
				-->
			<!-- TODO: if the default starting value becomes dynamic change this -->
			<header>
				<CharacterButton
						character="A"
						fontSize="20"
						fontX="12"
						fontY="19"
						size="24"
						strokeWidth="1"
						styles="left: 1px; position: absolute; top: -1px;"
				></CharacterButton>
				{poll.factors[voteFactor.factorNumber].name}
				{#if canRemove(voteFactors, i, delta)}
				<MoveButton
						on:selectStart="addOrRemove(-1, event)"
						classes="right"
						size="19"
						styles="left: 24px; position: absolute; top: -1.5px"
				></MoveButton>
				{/if}
				{#if i}
				<MoveButton
						on:selectStart="upStart(i, event)"
						classes="up"
						size="19"
						styles="right: 24px; position: absolute; top: -2px"
				></MoveButton>
				{/if}
			</header>
			<p
					style="color: #{getTextColor(poll.factors[voteFactor.factorNumber].color, logicUtils, delta)};"
			>
				{poll.factors[voteFactor.factorNumber].positions.A.name}
			</p>
		</var>
		{/if}
		{#if sideMatch(voteFactors[i], 'B', switchingOutcome)}
		<!--
		transition:fly='{x: -200, duration: 1000}'
		-->
		<var
				class="factor B
					{factorHighlight(movingVoteFactor, i, movingVoteFactorDelta, logic)}"
				style="background-color: #{getColor(poll.factors[voteFactor.factorNumber].color, logicUtils, delta)};"
		>
			<!--
				id="factor_{i}_B"
				-->
			<header>
				{poll.factors[voteFactor.factorNumber].name}
				<CharacterButton
						character="B"
						fontSize="20"
						fontX="12"
						fontY="19"
						size="24"
						strokeWidth="1"
						styles="right: 1px; position: absolute; top: -1px;"
				></CharacterButton>
				{#if canRemove(voteFactors, i, delta)}
				<MoveButton
						on:selectStart="addOrRemove(-1, event)"
						classes="right"
						size="19"
						styles="left: 24px; position: absolute; top: -1.5px"
				></MoveButton>
				{/if}
				{#if i}
				<MoveButton
						on:selectStart="upStart(i, event)"
						classes="up"
						size="19"
						styles="right: 24px; position: absolute; top: -2px"
				></MoveButton>
				{/if}
			</header>
			<p
					style="color: #{getTextColor(poll.factors[voteFactor.factorNumber].color, logicUtils, delta)};"
			>
				{poll.factors[voteFactor.factorNumber].positions.B.name}
			</p>
		</var>
		{/if}
	</figure>
	{:elseif showPlaceholder(removeCount, removeDoneCount)}
	<var
			class="placeholder"
	>

		<MoveButton
				on:selectStart="addOrRemove(1, event)"
				size="19"
				styles="left: 32px; position: absolute; top: 42px"
		></MoveButton>
	</var>
	{/if}
	{#if showMovePlaceholder(movingVoteFactor, i, movingVoteFactorDelta)}
	<figure>
		<var
				class="placeholder"
		>
		</var>
	</figure>
	{/if}
</section>
{/each}
{/if}
<style>

	@media (min-width: 321px) {
		header + p {
			font-size: 1.1em;
			line-height: 1.1em;
		}
	}

	@media (min-width: 376px) {
		header + p {
			font-size: 1.15em !important;
			line-height: 1.15em !important;
		}
	}

	figure {
		height: 100px;
		position: relative;
		transform-style: preserve-3d;
	}

	/*	footer {
			bottom: 0px;
		}*/

	/*footer,*/
	header {
		color: #fff;
		background-color: #000;
		font-size: 1.2em;
		font-weight: 500;
		line-height: 1.2em;
		overflow: hidden;
		position: absolute;
		text-align: center;
		text-overflow: ellipsis;
		width: 100%;
		white-space: nowrap;
	}

	header {
		top: 0px
	}

	header + p {
		margin: 0px;
		padding: 3px;
		position: absolute;
		top: 21px;
		word-break: break-word;
	}

	p {
		color: #000;
		font-size: 1.05em;
		line-height: 1.05em;
		margin-block-start: 0em;
		margin-block-end: 0em;
		padding: 7px 5px 14px 5px;
	}

	section {
		height: 100px;
	}

	var {
		border-radius: 5px;
		height: 100px;
		position: absolute;
		width: 100%;
	}

	var.factor {
		border: 3px solid gray;
	}

	var.factor.highlighted {
		border: 5px dashed red;
	}

	var.placeholder {
		border: 1px dotted gray;
	}

	.A {
		transform: translateZ(5px);
	}

	.B {
		transform: rotateY(180deg) translateZ(5px);
	}

	.factorFigure {
		left: 0px;
	}

	.isB {
		transform: rotateY(180deg);
	}

	.removingFactor {
		opacity: 0;
		left: -400px;
	}

</style>

<script>
	import {DI}              from '@airport/di'
	import {TOUCH}           from '@votecube/cube-logic'
	import {
		FACTOR_RANKING_LOGIC,
		LOGIC_UTILS
	}                        from '@votecube/public-logic'
	import {fly}             from 'svelte-transitions'
	import AddRemoveButton   from '../../common/control/button/AddRemoveButton.html'
	import CharacterButton   from '../../common/control/button/CharacterButton.html'
	import MoveButton        from '../../common/control/button/MoveButton.html'
	import SwapButton        from '../../common/control/button/SwapButton.html'
	import store             from '../../store'
	import DirectionSelector from '../vote/DirectionSelector.html'

	export default {
		components: {
			AddRemoveButton,
			CharacterButton,
			DirectionSelector,
			MoveButton,
			SwapButton
		},
		data() {
			return {
				factorOrderDelta: 0,
				movingVoteFactorDelta: 0,
				removeCount: 0,
				removeDoneCount: 0,
				showTransition: true,
				switchingOutcome: false
			}
		},
		helpers: {
			canRemove: (
				voteFactors,
				index
			) => index ? true : voteFactors[1].outcome,
			factorHighlight(
				movingVoteFactor,
				index,
				movingVoteFactorDelta,
				logic
			) {
				if (!movingVoteFactor || index === movingVoteFactor.index || !logic) {
					return ''
				}

				const factorInfo = logic.getFactorInfoAtCoords(
					movingVoteFactor.originalX, movingVoteFactor.pageY, movingVoteFactor.index)

				return factorInfo && factorInfo.factorNumber === index ? 'highlighted' : ''
			},
			factorPosition(
				$windowWidth,
				movingVoteFactor
			) {
				if (!movingVoteFactor.moving || !movingVoteFactor.outcome) {
					return ''
				}
				// let left = Math.ceil(movingVoteFactor.offset.topLeft.x)
				// let left = movingVoteFactor.pageX
				let top = movingVoteFactor.pageY
				if (movingVoteFactor.offset) {
					// left -= movingVoteFactor.offset.x
					top -= movingVoteFactor.offset.y
				}
				const xChange    = movingVoteFactor.originalX - movingVoteFactor.pageX
				const absXChange = Math.abs(xChange)
				const absYChange = Math.abs(movingVoteFactor.originalY - movingVoteFactor.pageY)

				if (movingVoteFactor.index > 0
					&& xChange > 0
					&& absXChange > absYChange
				) {
					if (movingVoteFactor.originalTopLeftY) {
						top = movingVoteFactor.originalTopLeftY
					}
				}
				const topOffset = $windowWidth > 320 ? 189 : 153

				// left: ${left}px;
				return `position: absolute;
					top: ${top - topOffset}px;
					width: ${movingVoteFactor.width}px;
					z-index: 5000;
					`
			},
			flyX: (
				voteFactor,
				// cubeTransition
			) => voteFactor.outcome === 'A' ? -200 : 200,
			// cubeTransition ? 0 : voteFactor.outcome === 'A' ? -200 : 200,
			getColor: (
				color,
				logicUtils
			) => {
				if (!logicUtils) {
					return 'FFF'
				}
				return logicUtils.getColor(color)
			},
			getTextColor: (
				color,
				logicUtils
			) => {
				if (!logicUtils) {
					return '000'
				}
				return logicUtils.getTextColor(color)
			},
			isB: (
				voteFactor
			) => voteFactor.outcome === 'B',
			showPlaceholder: (
				removeCount,
				removeDoneCount
			) => removeCount === removeDoneCount,
			showMovePlaceholder: (
				movingVoteFactor,
				index,
				movingVoteFactorDelta
			) => movingVoteFactor && movingVoteFactor.moving && index === movingVoteFactor.index,
			showPosition:
				(
					voteFactor
				) => voteFactor.value,
			sideMatch: (
				voteFactor,
				outcome,
				switchingOutcome
			) => switchingOutcome || outcome === voteFactor.outcome,
			transitionStyle: (
				showTransition
				// ) => showTransition ? 'transition: transform 1000ms linear;' : ''
			) => 'transition: left 700ms, opacity 700ms' + (showTransition ? ', transform 1000ms linear;' : ';')
		},
		methods: {
			moveEnd(
				movingVoteFactor,
				vote,
				voteFactors,
				index,
				event,
				logic
			) {
				if (!logic) {
					return
				}
				try {
					stopMoveEventListening()

					let {lastMoveStart} = this.get()

					if (!lastMoveStart
						||
						// Already added the factor in
						!movingVoteFactor) {
						return
					}

					const usefulEvent = event.changedTouches && event.changedTouches[0]
						? event.changedTouches[0] : event
					const factorInfo  = logic.getFactorInfoAtCoords(voteFactors[index].originalX, usefulEvent.pageY, index)
					if (factorInfo && factorInfo.factorNumber >= 0) {
						index = factorInfo.factorNumber
					}

					let dx      = movingVoteFactor.pageX - movingVoteFactor.originalX
					let dy      = movingVoteFactor.pageY - movingVoteFactor.originalY
					const absDx = Math.abs(dx)
					const absDy = Math.abs(dy)

					// console.log('moving: ' + index)
					// console.log(event)

					const originalIndex     = lastMoveStart.index
					const upButtonClickMove = lastMoveStart.move
					const addOrRemove       = lastMoveStart.addOrRemove

					DI.get(FACTOR_RANKING_LOGIC, LOGIC_UTILS).then(([
						                                                factorRankingLogic,
						                                                logicUtils
					                                                ]) => {
						if (!upButtonClickMove && originalIndex === index) {
							singleFactorChange(absDx, absDy, addOrRemove, dx, dy, index,
								originalIndex, upButtonClickMove, vote,
								voteFactors, this, factorRankingLogic, logicUtils)
						} else {
							multiFactorChange(absDx, absDy, dy, index,
								originalIndex, upButtonClickMove, vote,
								voteFactors, this, factorRankingLogic, logicUtils)
						}
					})
				} finally {
					stopVoteFactorMovement(this, movingVoteFactor)
				}
			},
			moveStart(
				voteFactors,
				index,
				event,
				logic
			) {
				let time               = new Date().getTime()
				const movingVoteFactor = voteFactors[index]

				const usefulEvent       = event.touches ? event.touches[0] : event
				movingVoteFactor.index  = index
				// Offset is only recorded once
				movingVoteFactor.offset = logic.getInElementOffset(usefulEvent)
				positionMovingVoteFactor(movingVoteFactor, usefulEvent)
				movingVoteFactor.originalX = movingVoteFactor.pageX
				movingVoteFactor.originalY = movingVoteFactor.pageY

				const move        = event.factorButtonMove
				const addOrRemove = event.factorButtonAddOrRemove
				if (addOrRemove || move) {
					movingVoteFactor.moving = true
				}
				movingVoteFactor.width = document.getElementById('factorPlace_' + index).clientWidth

				this.set({
					lastMoveStart: {
						index: event.factorButtonMove ? event.factorButtonIndex : index,
						move,
						addOrRemove,
						time
					},
					movingVoteFactor
				})
				incMovingDelta(this)

				if (!addOrRemove) {
					document.addEventListener('mousemove', getFactorMoveHandler(this))
					document.addEventListener('touchmove', getFactorMoveHandler(this))
					voteFactors[index].moving = true
				}
				// console.log('moveStart: ' + index)
				// console.log(event)
			},
			addOrRemove(
				operation,
				event
			) {
				event.factorButtonAddOrRemove = operation
			},
			touchStart(
				voteFactors,
				index,
				event
			) {
				// https://developer.mozilla.org/en-US/docs/Web/API/Touch_events/Supporting_both_TouchEvent_and_MouseEvent
				event.preventDefault()
				this.moveStart(voteFactors, index, event)
			},
			upStart(
				index,
				event
			) {
				event.factorButtonMove  = true
				event.factorButtonIndex = index - 1
				setTimeout(() => {
					DI.get(FACTOR_RANKING_LOGIC, LOGIC_UTILS).then(
						([factorRankingLogic, logicUtils]) => {
							factorRankingLogic.move(index - 1, {y: 100}, this, logicUtils)
							factorRankingLogic.move(index, {y: -100}, this, logicUtils)
						})
				}, 100)
			}
		},
		oncreate() {
			initPage(this).then()
		},
		store: () => store,
		transitions: {
			fly
		}
	}

	async function initPage(
		page
	) {
		const [logic, logicUtils] = await DI.get(FACTOR_RANKING_LOGIC, LOGIC_UTILS)

		page.set({logic, logicUtils})
	}

	function singleFactorChange(
		absDx,
		absDy,
		addOrRemove,
		dx,
		dy,
		index,
		originalIndex,
		upButtonClickMove,
		vote,
		voteFactors,
		page,
		factorRankingLogic,
		logicUtils
	) {
		if (!addOrRemove && absDx < 10 && absDy < 10) {
			changeFactorPosition(voteFactors, index, page, factorRankingLogic)
		}
		// Change to 1 factor only
		else if (addOrRemove || absDx - 10 > absDy) {
			handleMoveEffects(factorRankingLogic.addOrRemoveAFactor(
				voteFactors, index, addOrRemove ? addOrRemove : dx, vote, page), page)
			// if (addOrRemove === 1) {
			// 	setTimeout(() => {
			// 		move(index, {x: -200, duration: 700}, page)
			// 	})
			// }
		} else if (absDy >= 10 && absDx * 2 < absDy) {
			const index = factorRankingLogic.getAlternateIndex(
				absDy, dy, originalIndex, !!voteFactors[2].outcome)
			if (index !== originalIndex) {
				multiFactorChange(absDx, absDy, dy, index,
					originalIndex, upButtonClickMove, vote, voteFactors,
					page, factorRankingLogic, logicUtils)
			}
			// Else a no-op
		}
		// Else a no-op
	}

	function multiFactorChange(
		absDx,
		absDy,
		dy,
		index,
		originalIndex,
		upButtonClickMove,
		vote,
		voteFactors,
		page,
		factorRankingLogic,
		logicUtils
	) {
		// Change across multiple items
		if (upButtonClickMove || absDy - 10 > absDx) {
			if (!voteFactors[originalIndex].outcome
				|| !voteFactors[index].outcome) {
				return
			}
			// Move items
			if (upButtonClickMove || dy > 0) {
				handleMoveEffects({
					numMoved: factorRankingLogic.moveFactorDown(
						voteFactors, vote, originalIndex, index, page, page.store, logicUtils)
				}, page)
			} else {
				handleMoveEffects({
					numMoved: factorRankingLogic.moveFactorUp(
						voteFactors, vote, originalIndex, index, page, page.store, logicUtils)
				}, page)
			}
		}
		/* Not implemented
		else if (moveCoords.moveY) {
			// Add or remove items
			if (moveCoords.yBy <= 0) {
				removeFactors(voteFactors, this)
			} else {
				addFactors(voteFactors, lastMoveStart.index, index, this)
			}
		}
		*/
		// Else a no-op
	}

	function changeFactorPosition(
		voteFactors,
		index,
		page,
		factorRankingLogic
	) {
		if (!voteFactors[index].outcome) {
			// If the factor isn't shown don't change position
			return
		}
		let outcome = 'B'
		if (voteFactors[index].outcome === 'B') {
			outcome = 'A'
		}
		const lastTimeoutHandle = page.get().timeoutHandle
		if (lastTimeoutHandle) {
			clearTimeout(lastTimeoutHandle)
		}
		page.set({switchingOutcome: true})
		setTimeout(() => {
			page.get().vote.changeMillis = 1000
			factorRankingLogic.setOutcome(voteFactors, index, outcome
				// , page, true
			)
			page.set({
				timeoutHandle: setTimeout(() => {
					page.set({switchingOutcome: false})
				}, 1000)
			})
			// TODO: is ranking really adjusted in this case?
			// page.fire('rankingAdjusted')
		})
	}

	function getFactorMoveHandler(
		page
	) {
		onFactorMove.page = page

		return onFactorMove
	}

	function onFactorMove(
		event // event
	) {
		const touches = event.touches

		// Only perform rotation if one touch or mouse (e.g. still scale with pinch and zoom)
		if (!TOUCH || !(touches && touches.length > 1)) {
			try {
				event.preventDefault()
			} catch (error) {
				// console.log(error)
			}

			let position = touches ? touches[0] : event
			// Get touch co-ords
			// ev.originalEvent.touches ? ev = ev.originalEvent.touches[0] : null
			// dispatch 'move-viewport' event
			const page             = onFactorMove.page
			const movingVoteFactor = page.get().movingVoteFactor
			positionMovingVoteFactor(movingVoteFactor, position)

			// If the user is swiping in the factor
			if (movingVoteFactor.moving && !movingVoteFactor.outcome
				&& movingVoteFactor.originalX - movingVoteFactor.pageX < -10) {
				stopMoveEventListening(
					// page, movingVoteFactor
				)
				// stopping movement before adding factor to get the slide in animation
				stopVoteFactorMovement(page, movingVoteFactor)
				setTimeout(() => {

					const {voteFactors, vote} = page.get()
					// Proactively swipe in the factor
					DI.get([FACTOR_RANKING_LOGIC, LOGIC_UTILS]).then(([
						                                                  factorRankingLogic,
						                                                  logicUtils
					                                                  ]) => {
						handleMoveEffects(
							factorRankingLogic.addOrRemoveAFactor(
								voteFactors, movingVoteFactor.index, 1, vote,
								page, page.store, logicUtils
							), page)
					})
				})
			}
			incMovingDelta(page)
		}
	}

	function handleMoveEffects(
		results,
		page
	) {
		const {
			      numMoved,
			      placeholder
		      } = results
		if (numMoved) {
			pauseRotation(page)
			page.set({factorOrderDelta: page.get().factorOrderDelta + 1})
			page.fire('rankingAdjusted')
		}
		if (placeholder) {
			scheduleFactorPlaceholder(page)
		}
	}

	function stopMoveEventListening(
		// page,
		// movingVoteFactor
	) {
		document.removeEventListener('mousemove', onFactorMove)
		document.removeEventListener('touchmove', onFactorMove)
	}

	function stopVoteFactorMovement(
		page,
		movingVoteFactor
	) {
		if (movingVoteFactor) {
			movingVoteFactor.moving = false
		}
		page.set({
			movingVoteFactor: null,
		})
		incMovingDelta(page)
	}

	function positionMovingVoteFactor(
		movingVoteFactor,
		position
	) {
		movingVoteFactor.pageX = position.pageX
		movingVoteFactor.pageY = position.pageY
	}

	function scheduleFactorPlaceholder(
		page
	) {
		const newState = {removeCount: page.get().removeCount + 1}
		page.set(newState)
		setTimeout(() => {
			page.set({
				removeDoneCount: page.get().removeDoneCount + 1
			})
		}, 701)
	}

	function pauseRotation(
		page
	) {
		page.set({showTransition: false})
		setTimeout(() => {
			page.set({showTransition: true})
		}, 701)
	}

	function incMovingDelta(page) {
		page.set({movingVoteFactorDelta: page.get().movingVoteFactorDelta + 1})
		setTimeout(() => {
			page.set({movingVoteFactorDelta: page.get().movingVoteFactorDelta + 1})
			setTimeout(() => {
				page.set({movingVoteFactorDelta: page.get().movingVoteFactorDelta + 1})
			}, 100)
		})
	}

</script>
