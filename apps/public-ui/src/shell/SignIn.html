<ActionPopover
		on:cancel="fire('closed')"
>
	<div slot="header">
		{#if signIn}
		Sign In
		{:else}
		Sign Up
		{/if}
	</div>
	<div slot="content">
		{#if signIn}
		New Users: <a
			on:click="setSignIn(false)"
	>
		Sign Up
	</a>
		{:else}
		Existing Users: <a
			on:click="setSignIn(true)"
	>
		Sign In
	</a>
		{/if}
		<br>
		{#if error}
		<div
				class="error"
		>
			{error}
		</div>
		{/if}
		{#if signInForm}
		<form>
			{#if signIn}
			<!--			<legend>Create Poll</legend>-->
			<Text
					field="{signInForm.fields.username}"
			></Text>
			<Text
					field="{signInForm.fields.password}"
					type="password"
			></Text>
			{:else}
			<Text
					field="{signUpForm.fields.username}"
			></Text>
			<div class="pure-control-group">
				<Text
						field="{signUpForm.fields.password}"
						type="password"
				></Text>
			</div>
			<div class="pure-control-group">
				<Text
						field="{signUpForm.fields.passwordCheck}"
						type="password"
				></Text>
			</div>
			{/if}
			<br>
		</form>
		{/if}
		<br>
	</div>
	<div slot="actions">
		{#if signIn}
		<EnterButton
				on:select="signIn()"
		></EnterButton>
		{:else}
		<SaveButton
				on:select="signUp()"
		></SaveButton>
		{/if}
	</div>
</ActionPopover>
<style>
	.error {
		padding: 5px;
		text-align: center;
	}
</style>
<script>
	import {DI}                           from '@airport/di'
	import {AUTH}                         from '@votecube/public-logic'
	import EnterButton                    from '../common/control/button/EnterButton.html'
	import SaveButton                     from '../common/control/button/SaveButton.html'
	// import * as forms                     from '../form/forms'
	import Text                           from '../common/field/Text.html'
	import ActionPopover                  from '../common/shell/ActionPopover.html'
	import {loadForms}                    from '../libs/forms'
	import {loadLocations as loadLocText} from '../libs/text/locations'
	import store                          from '../store'

	export default {
		components: {
			ActionPopover,
			EnterButton,
			SaveButton,
			Text
		},
		data: () => ({
			signIn: true
		}),
		methods: {
			signIn() {
				const {signInForm} = this.get()
				if (!signInForm.valid) {
					return
				}
				doSignIn(signInForm.value.username, signInForm.value.password, this).then(
					success => {
						if (success) {
							this.fire('closed')
						}
					})
			},
			setSignIn(signIn) {
				this.set({signIn})
			},
			signUp() {
				const {signUpForm} = this.get()
				if (!signUpForm.valid) {
					return
				}
				doSignUp(signUpForm.value.username, signUpForm.value.password, this).then(
					success => {
						if (success) {
							this.fire('closed')
						}
					})
			}
		},
		oncreate() {
			initPage(this).then()
		},
		ondestroy() {
			const {container} = this.get()
			DI.remove(container)
		},
		store: () => store
	}

	async function initPage(page) {
		const [
			      formFactory,
			      _
		      ] = await Promise.all([
			loadForms(page.store),
			loadLocText(page.store, 'en-us')
		])

		const {text} = page.store.get()

		const signInForm = formFactory.group('SignIn', {
			username: formFactory.field([
				formFactory.validators.required(),
				formFactory.validators.minLength(5),
			], {maxLength: 64}),
			password: formFactory.field([
				formFactory.validators.required(),
				formFactory.validators.minLength(8),
			], {maxLength: 64})
		}, [formFactory.validators.required()], text.UI.SignIn, 'SignUp')

		const signUpForm = formFactory.group('SignUp', {
			username: formFactory.field([
				formFactory.validators.required(),
				formFactory.validators.minLength(5),
			], {maxLength: 64}),
			password: formFactory.field([
				formFactory.validators.required(),
				formFactory.validators.minLength(8),
			], {maxLength: 64}),
			passwordCheck: formFactory.field([
				formFactory.validators.required(),
				formFactory.validators.minLength(8), formFactory.validators.custom('passwordMismatch', (
					field
				) => {
					const passwordValue = field.group.fields.password.value
					const value         = field.value
					if (value !== passwordValue) {
						return {
							key: 'passwordMismatch'
						}
					}
				}),
			], {maxLength: 64}),
		}, [formFactory.validators.required()], text.UI.SignIn)

		const container  = DI.ui('SignIn')

		page.set({
			container,
			signInForm,
			signUpForm
		})
	}

	async function doSignIn(
		username,
		password,
		page
	) {
		const {container} = page.get()

		const auth  = await container.get(AUTH)
		const error = await auth.signIn(username, password)
		if (!error) {
			return true
		}
		switch (error.code) {
			case 'NotFound':
				page.set({error: 'Username not found.'})
				break
			case 'WrongPassword':
				page.set({error: 'Wrong password.'})
				break
			case 'TooManyTries':
				page.set({error: 'Too many Sign In requests, please try later.'})
				break
			default:
				page.set({error: 'Error Signing In.  Please check your network connection and try again.'})
				break
		}
		return false
	}


	async function doSignUp(
		username,
		password,
		page
	) {
		const {container} = page.get()

		const auth  = await container.get(AUTH)
		const error = await auth.signUp(username, password)
		if (!error) {
			return true
		}
		switch (error.code) {
			case 'InUse':
				page.set({error: 'Username already taken.'})
				break
			case 'Invalid':
				page.set({error: 'Invalid username.'})
				break
			default:
				page.set({error: 'Error Signing Up.  Please check your network connection and try again.'})
				break
		}
		return false
	}

</script>
